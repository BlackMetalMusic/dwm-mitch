diff -Narup 01_dwm-4.4.1_maximize/client.c 02_dwm-4.4.1_workspace/client.c
--- 01_dwm-4.4.1_maximize/client.c	2007-09-12 14:13:47.000000000 +0200
+++ 02_dwm-4.4.1_workspace/client.c	2007-09-12 14:13:47.000000000 +0200
@@ -184,8 +184,8 @@ manage(Window w, XWindowAttributes *wa) 
 	XWindowChanges wc;
 
 	c = emallocz(sizeof(Client));
-	c->tags = emallocz(ntags * sizeof(Bool));
 	c->win = w;
+	c->workspace = selws;
 	c->x = wa->x;
 	c->y = wa->y;
 	c->w = wa->width;
@@ -218,9 +218,6 @@ manage(Window w, XWindowAttributes *wa) 
 	updatetitle(c);
 	if((rettrans = XGetTransientForHint(dpy, w, &trans) == Success))
 		for(t = clients; t && t->win != trans; t = t->next);
-	if(t)
-		for(i = 0; i < ntags; i++)
-			c->tags[i] = t->tags[i];
 	applyrules(c);
 	if(!c->isfloating)
 		c->isfloating = (rettrans == Success) || c->isfixed;
@@ -315,11 +312,11 @@ unmanage(Client *c) {
 	XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
 	detach(c);
 	detachstack(c);
+	removefromstack(c);
 	if(sel == c)
 		focus(NULL);
 	XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
 	setclientstate(c, WithdrawnState);
-	free(c->tags);
 	free(c);
 	XSync(dpy, False);
 	XSetErrorHandler(xerror);
diff -Narup 01_dwm-4.4.1_maximize/config.default.h 02_dwm-4.4.1_workspace/config.default.h
--- 01_dwm-4.4.1_maximize/config.default.h	2007-09-12 14:13:47.000000000 +0200
+++ 02_dwm-4.4.1_workspace/config.default.h	2007-09-12 14:13:47.000000000 +0200
@@ -11,17 +11,14 @@
 #define SELBGCOLOR		"#006699"
 #define SELFGCOLOR		"#ffffff"
 
-/* tagging */
-#define TAGS \
-const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9", NULL };
 /* Query class:instance:title for regex matching info with following command:
  * xprop | awk -F '"' '/^WM_CLASS/ { printf("%s:%s:",$4,$2) }; /^WM_NAME/ { printf("%s\n",$2) }' */
 #define RULES \
 static Rule rules[] = { \
-	/* class:instance:title regex	tags regex	isfloating */ \
-	{ "Gimp",			NULL,		True }, \
-	{ "MPlayer",			NULL,		True }, \
-	{ "Acroread",			NULL,		True }, \
+	/* class:instance:title regex	isfloat workspace (0=current) */ \
+	{ "Gimp",			True,	0 }, \
+	{ "MPlayer",			True,	0 }, \
+	{ "Acroread",			True,	0 }, \
 };
 
 /* layout(s) */
@@ -37,6 +34,10 @@ static Layout layouts[] = { \
 #define MWFACT			0.6	/* master width factor [0.1 .. 0.9] */
 #define SNAP			32	/* snap pixel */
 
+#define INITIALWORKSPACES	1
+#define MAXWORKSPACES		99
+#define MAXWSTEXTWIDTH		6		/* must be 2*(strlen(MAXWORKSPACES)+1)  */
+
 /* key definitions */
 #define MODKEY			Mod1Mask
 #define KEYS \
@@ -46,51 +47,47 @@ Key keys[] = { \
 	{ MODKEY,			XK_p,		spawn, 		"exe=`dmenu_path | dmenu` && exec $exe" }, \
 	{ MODKEY,			XK_space,	setlayout,	NULL }, \
 	{ MODKEY,			XK_b,		togglebar,	NULL }, \
-	{ MODKEY,			XK_j,		focusnext,	NULL }, \
-	{ MODKEY,			XK_k,		focusprev,	NULL }, \
-	{ MODKEY,			XK_h,		setmwfact,	"-0.05" }, \
-	{ MODKEY,			XK_l,		setmwfact,	"+0.05" }, \
+	{ MODKEY,			XK_g,		setmwfact,	"-0.05" }, \
+	{ MODKEY,			XK_s,		setmwfact,	"+0.05" }, \
+/*	{ MODKEY|ShiftMask,		XK_g,		incnmaster,	"1" }, */ \
+/*	{ MODKEY|ShiftMask,		XK_s,		incnmaster,	"-1" }, */ \
+	{ MODKEY,			XK_j,		focusprev,	NULL }, \
+ 	{ MODKEY,			XK_k,		focusnext,	NULL }, \
+	{ MODKEY,			XK_a,		popstack,	NULL }, \
+	{ MODKEY,			XK_d,		pushstack,	NULL }, \
+	{ MODKEY|ControlMask,		XK_y,		wscount,	"1" }, \
+	{ MODKEY|ControlMask,		XK_r,		wscount,	"-1" }, \
 	{ MODKEY,			XK_m,		togglemax,	NULL }, \
 	{ MODKEY,			XK_Return,	zoom,		NULL }, \
 	{ MODKEY|ShiftMask,		XK_space,	togglefloating,	NULL }, \
 	{ MODKEY|ShiftMask,		XK_c,		killclient,	NULL }, \
-	{ MODKEY,			XK_0,		view,		NULL }, \
-	{ MODKEY,			XK_1,		view,		tags[0] }, \
-	{ MODKEY,			XK_2,		view,		tags[1] }, \
-	{ MODKEY,			XK_3,		view,		tags[2] }, \
-	{ MODKEY,			XK_4,		view,		tags[3] }, \
-	{ MODKEY,			XK_5,		view,		tags[4] }, \
-	{ MODKEY,			XK_6,		view,		tags[5] }, \
-	{ MODKEY,			XK_7,		view,		tags[6] }, \
-	{ MODKEY,			XK_8,		view,		tags[7] }, \
-	{ MODKEY,			XK_9,		view,		tags[8] }, \
-	{ MODKEY|ControlMask,		XK_1,		toggleview,	tags[0] }, \
-	{ MODKEY|ControlMask,		XK_2,		toggleview,	tags[1] }, \
-	{ MODKEY|ControlMask,		XK_3,		toggleview,	tags[2] }, \
-	{ MODKEY|ControlMask,		XK_4,		toggleview,	tags[3] }, \
-	{ MODKEY|ControlMask,		XK_5,		toggleview,	tags[4] }, \
-	{ MODKEY|ControlMask,		XK_6,		toggleview,	tags[5] }, \
-	{ MODKEY|ControlMask,		XK_7,		toggleview,	tags[6] }, \
-	{ MODKEY|ControlMask,		XK_8,		toggleview,	tags[7] }, \
-	{ MODKEY|ControlMask,		XK_9,		toggleview,	tags[8] }, \
-	{ MODKEY|ShiftMask,		XK_0,		tag,		NULL }, \
-	{ MODKEY|ShiftMask,		XK_1,		tag,		tags[0] }, \
-	{ MODKEY|ShiftMask,		XK_2,		tag,		tags[1] }, \
-	{ MODKEY|ShiftMask,		XK_3,		tag,		tags[2] }, \
-	{ MODKEY|ShiftMask,		XK_4,		tag,		tags[3] }, \
-	{ MODKEY|ShiftMask,		XK_5,		tag,		tags[4] }, \
-	{ MODKEY|ShiftMask,		XK_6,		tag,		tags[5] }, \
-	{ MODKEY|ShiftMask,		XK_7,		tag,		tags[6] }, \
-	{ MODKEY|ShiftMask,		XK_8,		tag,		tags[7] }, \
-	{ MODKEY|ShiftMask,		XK_9,		tag,		tags[8] }, \
-	{ MODKEY|ControlMask|ShiftMask,	XK_1,		toggletag,	tags[0] }, \
-	{ MODKEY|ControlMask|ShiftMask,	XK_2,		toggletag,	tags[1] }, \
-	{ MODKEY|ControlMask|ShiftMask,	XK_3,		toggletag,	tags[2] }, \
-	{ MODKEY|ControlMask|ShiftMask,	XK_4,		toggletag,	tags[3] }, \
-	{ MODKEY|ControlMask|ShiftMask,	XK_5,		toggletag,	tags[4] }, \
-	{ MODKEY|ControlMask|ShiftMask,	XK_6,		toggletag,	tags[5] }, \
-	{ MODKEY|ControlMask|ShiftMask,	XK_7,		toggletag,	tags[6] }, \
-	{ MODKEY|ControlMask|ShiftMask,	XK_8,		toggletag,	tags[7] }, \
-	{ MODKEY|ControlMask|ShiftMask,	XK_9,		toggletag,	tags[8] }, \
+	{ MODKEY,			XK_1,		view,		"1" }, \
+	{ MODKEY,			XK_2,		view,		"2" }, \
+	{ MODKEY,			XK_3,		view,		"3" }, \
+	{ MODKEY,			XK_4,		view,		"4" }, \
+	{ MODKEY,			XK_5,		view,		"5" }, \
+	{ MODKEY,			XK_6,		view,		"6" }, \
+	{ MODKEY,			XK_7,		view,		"7" }, \
+	{ MODKEY,			XK_8,		view,		"8" }, \
+	{ MODKEY,			XK_9,		view,		"9" }, \
+	{ MODKEY,			XK_0,		view,		"10" }, \
+	{ MODKEY|ShiftMask,		XK_1,		moveto,		"1" }, \
+	{ MODKEY|ShiftMask,		XK_2,		moveto,		"2" }, \
+	{ MODKEY|ShiftMask,		XK_3,		moveto,		"3" }, \
+	{ MODKEY|ShiftMask,		XK_4,		moveto,		"4" }, \
+	{ MODKEY|ShiftMask,		XK_5,		moveto,		"5" }, \
+	{ MODKEY|ShiftMask,		XK_6,		moveto,		"6" }, \
+	{ MODKEY|ShiftMask,		XK_7,		moveto,		"7" }, \
+	{ MODKEY|ShiftMask,		XK_8,		moveto,		"8" }, \
+	{ MODKEY|ShiftMask,		XK_9,		moveto,		"9" }, \
+	{ MODKEY|ShiftMask,		XK_0,		moveto,		"10" }, \
+	{ MODKEY,			XK_l,		viewrel,	"1" }, \
+	{ MODKEY,			XK_h,		viewrel,	"-1" }, \
+	{ MODKEY|ShiftMask,		XK_l,		pushstack,	NULL }, \
+	{ MODKEY|ShiftMask,		XK_l,		viewrel,	"1" }, \
+	{ MODKEY|ShiftMask,		XK_l,		popstack,	NULL }, \
+	{ MODKEY|ShiftMask,		XK_h,		pushstack,	NULL }, \
+	{ MODKEY|ShiftMask,		XK_h,		viewrel,	"-1" }, \
+	{ MODKEY|ShiftMask,		XK_h,		popstack,	NULL }, \
 	{ MODKEY|ShiftMask,		XK_q,		quit,		NULL }, \
 };
diff -Narup 01_dwm-4.4.1_maximize/draw.c 02_dwm-4.4.1_workspace/draw.c
--- 01_dwm-4.4.1_maximize/draw.c	2007-09-12 14:13:47.000000000 +0200
+++ 02_dwm-4.4.1_workspace/draw.c	2007-09-12 14:13:47.000000000 +0200
@@ -25,16 +25,6 @@ drawsquare(Bool filled, Bool empty, unsi
 	}
 }
 
-static Bool
-isoccupied(unsigned int t) {
-	Client *c;
-
-	for(c = clients; c; c = c->next)
-		if(c->tags[t])
-			return True;
-	return False;
-}
-
 static unsigned int
 textnw(const char *text, unsigned int len) {
 	XRectangle r;
@@ -50,21 +40,12 @@ textnw(const char *text, unsigned int le
 
 void
 drawstatus(void) {
-	int i, x;
+	int x;
 
 	dc.x = dc.y = 0;
-	for(i = 0; i < ntags; i++) {
-		dc.w = textw(tags[i]);
-		if(seltags[i]) {
-			drawtext(tags[i], dc.sel);
-			drawsquare(sel && sel->tags[i], isoccupied(i), dc.sel);
-		}
-		else {
-			drawtext(tags[i], dc.norm);
-			drawsquare(sel && sel->tags[i], isoccupied(i), dc.norm);
-		}
-		dc.x += dc.w;
-	}
+	dc.w = wstextwidth;
+	drawtext(wstext, dc.norm);
+	dc.x = dc.w;
 	dc.w = blw;
 	drawtext(getsymbol(), dc.norm);
 	x = dc.x + dc.w;
diff -Narup 01_dwm-4.4.1_maximize/dwm.h 02_dwm-4.4.1_workspace/dwm.h
--- 01_dwm-4.4.1_maximize/dwm.h	2007-09-12 14:13:47.000000000 +0200
+++ 02_dwm-4.4.1_workspace/dwm.h	2007-09-12 14:13:47.000000000 +0200
@@ -49,9 +49,8 @@ struct Client {
 	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
 	int minax, maxax, minay, maxay;
 	long flags; 
-	unsigned int border, oldborder;
+	unsigned int border, oldborder, workspace;
 	Bool isbanned, isfixed, ismax, isfloating;
-	Bool *tags;
 	Client *next;
 	Client *prev;
 	Client *snext;
@@ -73,20 +72,22 @@ typedef struct {
 	} font;
 } DC; /* draw context */
 
-extern const char *tags[];			/* all tags */
 extern char stext[256];				/* status text */
 extern int screen, sx, sy, sw, sh;		/* screen geometry */
 extern int wax, way, wah, waw;			/* windowarea geometry */
 extern unsigned int bh, blw, bpos;		/* bar height, bar layout label width, bar position */
-extern unsigned int ntags, numlockmask;		/* number of tags, numlock mask */
+extern unsigned int numlockmask;		/*  numlock mask */
+extern unsigned int selws, workspaces;		/* current workspace and total workspaces */
 extern void (*handler[LASTEvent])(XEvent *);	/* event handler */
 extern Atom wmatom[WMLast], netatom[NetLast];
-extern Bool selscreen, *seltags;		/* seltags is array of Bool */
+extern Bool selscreen;
 extern Client *clients, *sel, *stack;		/* global client list and stack */
 extern Cursor cursor[CurLast];
 extern DC dc;					/* global draw context */
 extern Display *dpy;
 extern Window root, barwin;
+extern char wstext[MAXWSTEXTWIDTH];
+extern int wstextwidth;
 
 /* client.c */
 void attach(Client *c);			/* attaches c to global client list */
@@ -131,14 +132,19 @@ Bool isvisible(Client *c);		/* returns T
 Client *nexttiled(Client *c);		/* returns tiled successor of c */
 void restack(void);			/* restores z layers of all clients */
 void setlayout(const char *arg);	/* sets layout, NULL means next layout */
-void tag(const char *arg);		/* tags sel with arg's index */
 void togglebar(const char *arg);	/* shows/hides the bar */
 void togglefloating(const char *arg);	/* toggles sel between floating/tiled state */
 void togglemax(const char *arg);	/* toggles maximization of floating client */
-void toggletag(const char *arg);	/* toggles sel tags with arg's index */
-void toggleview(const char *arg);	/* toggles the tag with arg's index (in)visible */
 void updatebarpos(void);		/* updates the bar position */
-void view(const char *arg);		/* views the tag with arg's index */
+void view(const char *arg);		/* views the workspace with arg's index */
+void viewrel(const char *arg);		/* views the workspace with arg's index (relative to current) */
+void pushstack(const char *arg);	/* pushes the client to the stack */
+void popstack(const char *arg);		/* pops newest client from the stack */
+void wscount(const char *arg);		/* changes the number of workspaces */;
+void moveto(const char *arg);		/* moves client to the workspace with arg's index */
+void processrules(Client *c);		/* set float mode and workspace of c */
+void updatewstext(void);		/* update workspace information in bar */
+void removefromstack(Client *c);	/* remove a client from detached stack */
 
 /* util.c */
 void *emallocz(unsigned int size);	/* allocates zero-initialized memory, exits on error */
diff -Narup 01_dwm-4.4.1_maximize/event.c 02_dwm-4.4.1_workspace/event.c
--- 01_dwm-4.4.1_maximize/event.c	2007-09-12 14:13:47.000000000 +0200
+++ 02_dwm-4.4.1_workspace/event.c	2007-09-12 14:13:47.000000000 +0200
@@ -109,29 +109,26 @@ resizemouse(Client *c) {
 
 static void
 buttonpress(XEvent *e) {
-	unsigned int i, x;
+	unsigned int x;
 	Client *c;
 	XButtonPressedEvent *ev = &e->xbutton;
 
 	if(barwin == ev->window) {
-		x = 0;
-		for(i = 0; i < ntags; i++) {
-			x += textw(tags[i]);
-			if(ev->x < x) {
-				if(ev->button == Button1) {
-					if(ev->state & MODKEY)
-						tag(tags[i]);
-					else
-						view(tags[i]);
-				}
-				else if(ev->button == Button3) {
-					if(ev->state & MODKEY)
-						toggletag(tags[i]);
-					else
-						toggleview(tags[i]);
-				}
-				return;
+		x = textw(wstext);
+		if(ev->x < x) {
+			if(ev->button == Button1) {
+				if(ev->state & MODKEY)
+					viewrel("-1");
+				else
+					viewrel("1");
 			}
+			else if(ev->button == Button3) {
+				if(ev->state & MODKEY)
+					wscount("-1");
+				else
+					wscount("1");
+			}
+			return;
 		}
 		if((ev->x < x + blw) && ev->button == Button1)
 			setlayout(NULL);
diff -Narup 01_dwm-4.4.1_maximize/main.c 02_dwm-4.4.1_workspace/main.c
--- 01_dwm-4.4.1_maximize/main.c	2007-09-12 14:13:47.000000000 +0200
+++ 02_dwm-4.4.1_workspace/main.c	2007-09-12 14:13:47.000000000 +0200
@@ -17,11 +17,12 @@
 
 char stext[256];
 int screen, sx, sy, sw, sh, wax, way, waw, wah;
-unsigned int bh, ntags;
+unsigned int bh;
 unsigned int bpos = BARPOS;
 unsigned int numlockmask = 0;
+unsigned int workspaces = INITIALWORKSPACES;
+unsigned int selws = 1;
 Atom wmatom[WMLast], netatom[NetLast];
-Bool *seltags;
 Bool selscreen = True;
 Client *clients = NULL;
 Client *sel = NULL;
@@ -57,7 +58,6 @@ cleanup(void) {
 	XFreeCursor(dpy, cursor[CurMove]);
 	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
 	XSync(dpy, False);
-	free(seltags);
 }
 
 static unsigned long
@@ -194,9 +194,6 @@ setup(void) {
 	XSelectInput(dpy, root, wa.event_mask);
 	grabkeys();
 	compileregs();
-	for(ntags = 0; tags[ntags]; ntags++);
-	seltags = emallocz(sizeof(Bool) * ntags);
-	seltags[0] = True;
 	/* style */
 	dc.norm[ColBorder] = initcolor(NORMBORDERCOLOR);
 	dc.norm[ColBG] = initcolor(NORMBGCOLOR);
@@ -230,6 +227,11 @@ setup(void) {
 		XSetFont(dpy, dc.gc, dc.font.xfont->fid);
 	/* multihead support */
 	selscreen = XQueryPointer(dpy, root, &w, &w, &i, &i, &i, &i, &mask);
+	/* check initial parameters */
+	if (workspaces < 1)
+		workspaces = 1;
+	else if (workspaces > MAXWORKSPACES)
+		workspaces = MAXWORKSPACES;
 }
 
 /*
@@ -326,6 +328,7 @@ main(int argc, char *argv[]) {
 	xerrorxlib = XSetErrorHandler(xerror);
 	XSync(dpy, False);
 	setup();
+	updatewstext();
 	drawstatus();
 	scan();
 
diff -Narup 01_dwm-4.4.1_maximize/screen.c 02_dwm-4.4.1_workspace/screen.c
--- 01_dwm-4.4.1_maximize/screen.c	2007-09-12 14:13:47.000000000 +0200
+++ 02_dwm-4.4.1_workspace/screen.c	2007-09-12 14:27:29.000000000 +0200
@@ -15,33 +15,40 @@ typedef struct {
 
 typedef struct {
 	const char *prop;
-	const char *tags;
 	Bool isfloating;
+	int workspace;
 } Rule;
 
 typedef struct {
 	regex_t *propregex;
-	regex_t *tagregex;
 } Regs;
 
-TAGS
+typedef struct Stack Stack;
+struct Stack {
+	Client *client;
+	Stack *next;
+};
+
 RULES
 
 static unsigned int nrules = 0;
 static unsigned int nlayouts = 0;
 static unsigned int ltidx = 0; /* default */
 static Regs *regs = NULL;
+static Stack *detachstack = NULL;
 
-static unsigned int
-idxoftag(const char *tag) {
-	unsigned int i;
-
-	for(i = 0; i < ntags; i++)
-		if(tags[i] == tag)
-			return i;
-	return 0;
+static void
+pushtostack(Client *c) {
+	Stack *new;
+	
+	new = emallocz(sizeof(Stack));
+	c->workspace = 0;
+	new->client = c;
+	new->next = detachstack;
+	detachstack = new;
 }
 
+
 static void
 floating(void) { /* default floating layout */
 	Client *c;
@@ -56,13 +63,14 @@ LAYOUTS
 /* extern */
 
 unsigned int blw = 0;
+char wstext[MAXWSTEXTWIDTH];
+int wstextwidth = 0;
 
 void
 applyrules(Client *c) {
 	static char buf[512];
-	unsigned int i, j;
+	unsigned int i;
 	regmatch_t tmp;
-	Bool matched = False;
 	XClassHint ch = { 0 };
 
 	/* rule matching */
@@ -73,20 +81,13 @@ applyrules(Client *c) {
 	for(i = 0; i < nrules; i++)
 		if(regs[i].propregex && !regexec(regs[i].propregex, buf, 1, &tmp, 0)) {
 			c->isfloating = rules[i].isfloating;
-			for(j = 0; regs[i].tagregex && j < ntags; j++) {
-				if(!regexec(regs[i].tagregex, tags[j], 1, &tmp, 0)) {
-					matched = True;
-					c->tags[j] = True;
-				}
-			}
+			if((rules[i].workspace > 0) && (rules[i].workspace <= workspaces))
+				c->workspace = rules[i].workspace;
 		}
 	if(ch.res_class)
 		XFree(ch.res_class);
 	if(ch.res_name)
 		XFree(ch.res_name);
-	if(!matched)
-		for(i = 0; i < ntags; i++)
-			c->tags[i] = seltags[i];
 }
 
 void
@@ -120,13 +121,6 @@ compileregs(void) {
 			else
 				regs[i].propregex = reg;
 		}
-		if(rules[i].tags) {
-			reg = emallocz(sizeof(regex_t));
-			if(regcomp(reg, rules[i].tags, REG_EXTENDED))
-				free(reg);
-			else
-				regs[i].tagregex = reg;
-		}
 	}
 }
 
@@ -193,12 +187,7 @@ isarrange(void (*func)())
 
 Bool
 isvisible(Client *c) {
-	unsigned int i;
-
-	for(i = 0; i < ntags; i++)
-		if(c->tags[i] && seltags[i])
-			return True;
-	return False;
+	return (c->workspace == selws);
 }
 
 Client *
@@ -259,16 +248,26 @@ setlayout(const char *arg) {
 }
 
 void
-tag(const char *arg) {
-	unsigned int i;
+updatewstext(void) {
+	snprintf(wstext, MAXWSTEXTWIDTH, "%d/%d", selws, workspaces);
+	wstextwidth = textw(wstext);
+}
 
-	if(!sel)
+void
+viewrel(const char *arg) {
+	int i;
+	
+	if (workspaces == 1)
+		return;
+ 	i = arg ? atoi(arg) : 0;
+	if (i == 0)
 		return;
-	for(i = 0; i < ntags; i++)
-		sel->tags[i] = arg == NULL;
-	i = idxoftag(arg);
-	if(i >= 0 && i < ntags)
-		sel->tags[i] = True;
+	selws += i;
+	if (selws > workspaces)
+		selws = 1;
+	if (selws < 1)
+		selws = workspaces;
+	updatewstext();
 	arrange();
 }
 
@@ -312,28 +311,77 @@ togglemax(const char *arg) {
 }
 
 void
-toggletag(const char *arg) {
-	unsigned int i, j;
+view(const char *arg) {
+	int i;
+	
+	i = arg ? atoi(arg) : 0;
+	if ((i < 1) || (i > workspaces) || (i == selws))
+		return;
+	selws = i;
+	updatewstext();
+	arrange();
+}
 
-	if(!sel)
+void
+pushstack(const char *arg) {
+	if (!sel)
+		return;
+	pushtostack(sel);
+	arrange();
+}
+
+void
+popstack(const char *arg) {
+	Stack *top;
+	
+	if (!detachstack)
 		return;
-	i = idxoftag(arg);
-	sel->tags[i] = !sel->tags[i];
-	for(j = 0; j < ntags && !sel->tags[j]; j++);
-	if(j == ntags)
-		sel->tags[i] = True;
+	top = detachstack;
+	detachstack = top->next;
+	sel = top->client;
+	free(top);
+	sel->workspace = selws;
+	detach(sel);
+	if (clients)
+		clients->prev = sel;
+	sel->next = clients;
+	clients = sel;
+	focus(sel);
 	arrange();
 }
 
 void
-toggleview(const char *arg) {
-	unsigned int i, j;
+wscount(const char *arg) {
+	Client *c;
+	int i;
 
-	i = idxoftag(arg);
-	seltags[i] = !seltags[i];
-	for(j = 0; j < ntags && !seltags[j]; j++);
-	if(j == ntags)
-		seltags[i] = True; /* cannot toggle last view */
+ 	i = arg ? atoi(arg) : 0;
+	if (i == 0 )
+		return;
+	if (i > 0) {
+		if (workspaces == MAXWORKSPACES)
+			return;
+		workspaces += i;
+		if (workspaces > MAXWORKSPACES)
+			workspaces = MAXWORKSPACES;
+		selws = workspaces;
+	}
+	else {
+		i = workspaces + i;
+		if (i < 1)
+			i = 1;
+		while (i < workspaces) {
+			for(c = clients; c; c = c->next)
+				if (c->workspace > selws)
+					c->workspace--;
+				else if (c->workspace == selws)
+					pushtostack(c);
+			if (selws == workspaces)
+				selws--;
+			workspaces--;
+		}
+	}
+	updatewstext();
 	arrange();
 }
 
@@ -364,13 +412,45 @@ updatebarpos(void) {
 }
 
 void
-view(const char *arg) {
-	unsigned int i;
+moveto(const char *arg) {
+	int i;
 
-	for(i = 0; i < ntags; i++)
-		seltags[i] = arg == NULL;
-	i = idxoftag(arg);
-	if(i >= 0 && i < ntags)
-		seltags[i] = True;
+	if (!sel)
+		return;
+ 	i = arg ? atoi(arg) : 0;
+	if ((i < 1) || (i > workspaces))
+		return;
+	sel->workspace = i;
 	arrange();
 }
+
+void
+removefromstack(Client *c) {
+	Stack *s, *tmp;
+
+	/* not on stack */
+	if (c->workspace != 0)
+		return;
+	/* empty stack --> should not be on stack then! */
+	if (!detachstack)
+		return;
+
+	/* first element on stack */
+	if (detachstack->client == c) {
+		tmp = detachstack;
+		detachstack = tmp->next;
+		free(tmp);
+		return;
+	}
+
+	/* somewhere else on the stack */
+	tmp = detachstack;
+	for(s = detachstack->next; s; s = s->next) {
+		if (s->client == c) {
+			tmp->next = s->next;
+			free(s);
+			return;
+		}
+		tmp = s;
+	}
+}
