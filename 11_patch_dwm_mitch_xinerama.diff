diff -Narup 10_dwm-4.7_tileleft/bstack.c 11_dwm-4.7_xinerama/bstack.c
--- 10_dwm-4.7_tileleft/bstack.c	2010-02-19 22:12:14.000000000 +0100
+++ 11_dwm-4.7_xinerama/bstack.c	2010-02-19 22:12:14.000000000 +0100
@@ -7,33 +7,33 @@ bstack(void) {
     for(n = 0, c = nexttiled(clients); c; c = nexttiled(c->next))
         n++;
 
-    mh = (n == 1) ? wah : mwfact[selws-1] * wah;
-    tw = (n > 1) ? waw / (n - 1) : 0;
+    mh = (n == 1) ? wah[SCREEN] : mwfact[selws-1] * wah[SCREEN];
+    tw = (n > 1) ? waw[SCREEN] / (n - 1) : 0;
 
-    nx = wax;
-    ny = way;
+    nx = wax[SCREEN];
+    ny = way[SCREEN];
     nh = 0;
     for(i = 0, c = mc = nexttiled(clients); c; c = nexttiled(c->next), i++) {
         c->ismax = False;
         if(i == 0) {
             nh = mh - 2 * c->border;
-            nw = waw - 2 * c->border;
+            nw = waw[SCREEN] - 2 * c->border;
         }
         else {
             if(i == 1) {
-                nx = wax;
+                nx = wax[SCREEN];
                 ny += mc->h + 2 * mc->border;
-                nh = (way + wah) - ny - 2 * c->border;
+                nh = (way[SCREEN] + wah[SCREEN]) - ny - 2 * c->border;
             }
             if(i + 1 == n)
-                nw = (wax + waw) - nx - 2 * c->border;
+                nw = (wax[SCREEN] + waw[SCREEN]) - nx - 2 * c->border;
             else
                 nw = tw - 2 * c->border;
         }
         resize(c, nx, ny, nw, nh, RESIZEHINTS);
         if((RESIZEHINTS) && ((c->h < bh) || (c->h > nh) || (c->w < bh) || (c->w > nw)))
             resize(c, nx, ny, nw, nh, False);
-        if(n > 1 && tw != waw)
+        if(n > 1 && tw != waw[SCREEN])
             nx = c->x + c->w + 2 * c->border;
     }
 }
diff -Narup 10_dwm-4.7_tileleft/config.def.h 11_dwm-4.7_xinerama/config.def.h
--- 10_dwm-4.7_tileleft/config.def.h	2010-02-19 22:12:14.000000000 +0100
+++ 11_dwm-4.7_xinerama/config.def.h	2010-02-19 22:26:23.000000000 +0100
@@ -25,6 +25,10 @@ Rule rules[] = {
 #define INITIALWORKSPACES	 1
 #define MAXWORKSPACES		99
 #define MAXWSTEXTWIDTH		 6	/* must be 2*(strlen(MAXWORKSPACES)+1)  */
+#define MAXXINERAMASCREENS	 2
+
+/* ugly: depending on constants above but needed by layouts below */
+int wax[MAXXINERAMASCREENS], way[MAXXINERAMASCREENS], waw[MAXXINERAMASCREENS], wah[MAXXINERAMASCREENS];
 
 /* layout(s) */
 #define MWFACT			0.6	/* master width factor [0.1 .. 0.9] */
diff -Narup 10_dwm-4.7_tileleft/config.mk 11_dwm-4.7_xinerama/config.mk
--- 10_dwm-4.7_tileleft/config.mk	2010-02-19 22:12:14.000000000 +0100
+++ 11_dwm-4.7_xinerama/config.mk	2010-02-19 22:12:14.000000000 +0100
@@ -15,7 +15,7 @@ X11LIB = /usr/X11R6/lib
 
 # includes and libs
 INCS = -I. -I/usr/include -I${X11INC}
-LIBS = -L/usr/lib -lc -L${X11LIB} -lX11
+LIBS = -L/usr/lib -lc -L${X11LIB} -lX11 -lXinerama
 
 # flags
 CFLAGS = -Os ${INCS} -DVERSION=\"${VERSION}\"
diff -Narup 10_dwm-4.7_tileleft/dwm.c 11_dwm-4.7_xinerama/dwm.c
--- 10_dwm-4.7_tileleft/dwm.c	2010-02-19 22:12:14.000000000 +0100
+++ 11_dwm-4.7_xinerama/dwm.c	2010-02-19 23:28:36.000000000 +0100
@@ -41,6 +41,7 @@
 #include <X11/Xlib.h>
 #include <X11/Xproto.h>
 #include <X11/Xutil.h>
+#include <X11/extensions/Xinerama.h>
 
 /* macros */
 #define BUTTONMASK		(ButtonPressMask | ButtonReleaseMask)
@@ -48,7 +49,8 @@
 #define LENGTH(x)		(sizeof x / sizeof x[0])
 #define MAXTAGLEN		16
 #define MOUSEMASK		(BUTTONMASK | PointerMotionMask)
-
+#define SCREEN 0
+// TODO SCREEN raus
 
 /* enums */
 enum { BarTop, BarBot, BarOff };			/* bar position */
@@ -125,7 +127,9 @@ void compileregs(void);
 void configure(Client *c);
 void configurenotify(XEvent *e);
 void configurerequest(XEvent *e);
+void createbarwins(void);
 void destroynotify(XEvent *e);
+void destroybarwins(void);
 void detach(Client *c);
 void detachstack(Client *c);
 void doreload(void);
@@ -188,6 +192,7 @@ void unmapnotify(XEvent *e);
 void updatebarpos(void);
 void updatesizehints(Client *c);
 void updatetitle(Client *c);
+void updatexinerama(void);
 void updatewstext(void);
 void view(const char *arg);
 void viewrel(const char *arg);
@@ -199,7 +204,9 @@ void zoom(const char *arg);
 
 /* variables */
 char stext[256];
-int screen, sx, sy, sw, sh, wax, way, waw, wah;
+int screen, totalw, totalh;
+int totalx = 0, totaly = 0;
+unsigned int screenmax = 0;
 int (*xerrorxlib)(Display *, XErrorEvent *);
 unsigned int bh, bpos;
 unsigned int blw = 0;
@@ -234,7 +241,7 @@ Client *stack = NULL;
 Cursor cursor[CurLast];
 Display *dpy;
 DC dc = {0};
-Window barwin, root;
+Window root;
 Regs *regs = NULL;
 char **cargv;
 
@@ -249,6 +256,8 @@ Layout *layout[MAXWORKSPACES];
 double mwfact[MAXWORKSPACES];
 unsigned int workspaces = INITIALWORKSPACES;
 char wstext[MAXWSTEXTWIDTH];
+int sx[MAXXINERAMASCREENS], sy[MAXXINERAMASCREENS], sw[MAXXINERAMASCREENS], sh[MAXXINERAMASCREENS];
+Window barwin[MAXXINERAMASCREENS];
 
 /* function implementations */
 void
@@ -307,7 +316,7 @@ void
 ban(Client *c) {
 	if(c->isbanned)
 		return;
-	XMoveWindow(dpy, c->win, c->x + 2 * sw, c->y);
+	XMoveWindow(dpy, c->win, c->x + 2 * sw[SCREEN], c->y);
 	c->isbanned = True;
 }
 
@@ -317,7 +326,7 @@ buttonpress(XEvent *e) {
 	Client *c;
 	XButtonPressedEvent *ev = &e->xbutton;
 
-	if(ev->window == barwin) {
+	if(ev->window == barwin[SCREEN]) {
 		x = textw(wstext);
 		if(ev->x < x) {
 			if(ev->button == Button1) {
@@ -397,7 +406,7 @@ cleanup(void) {
 	XUngrabKey(dpy, AnyKey, AnyModifier, root);
 	XFreePixmap(dpy, dc.drawable);
 	XFreeGC(dpy, dc.gc);
-	XDestroyWindow(dpy, barwin);
+	destroybarwins();
 	XFreeCursor(dpy, cursor[CurNormal]);
 	XFreeCursor(dpy, cursor[CurResize]);
 	XFreeCursor(dpy, cursor[CurMove]);
@@ -406,6 +415,15 @@ cleanup(void) {
 }
 
 void
+destroybarwins(void) {
+	unsigned int i;
+
+	for(i = 0; i < screenmax; i++) {
+		XDestroyWindow(dpy, barwin[i]);
+	}
+}
+
+void
 compileregs(void) {
 	unsigned int i;
 	regex_t *reg;
@@ -446,14 +464,10 @@ void
 configurenotify(XEvent *e) {
 	XConfigureEvent *ev = &e->xconfigure;
 
-	if(ev->window == root && (ev->width != sw || ev->height != sh)) {
-		sw = ev->width;
-		sh = ev->height;
-		XFreePixmap(dpy, dc.drawable);
-		dc.drawable = XCreatePixmap(dpy, root, sw, bh, DefaultDepth(dpy, screen));
-		XResizeWindow(dpy, barwin, sw, bh);
-		updatebarpos();
+	if(ev->window == root) {
+		updatexinerama();
 		arrange();
+		
 	}
 }
 
@@ -476,10 +490,10 @@ configurerequest(XEvent *e) {
 				c->w = ev->width;
 			if(ev->value_mask & CWHeight)
 				c->h = ev->height;
-			if((c->x + c->w) > sw && c->isfloating)
-				c->x = sw / 2 - c->w / 2; /* center in x direction */
-			if((c->y + c->h) > sh && c->isfloating)
-				c->y = sh / 2 - c->h / 2; /* center in y direction */
+			if((c->x + c->w) > sw[SCREEN] && c->isfloating)
+				c->x = sw[SCREEN] / 2 - c->w / 2; /* center in x direction */
+			if((c->y + c->h) > sh[SCREEN] && c->isfloating)
+				c->y = sh[SCREEN] / 2 - c->h / 2; /* center in y direction */
 			if((ev->value_mask & (CWX | CWY))
 			&& !(ev->value_mask & (CWWidth | CWHeight)))
 				configure(c);
@@ -539,30 +553,33 @@ doreload(void) {
 void
 drawbar(void) {
 	int x;
+	unsigned int i;
 
-	dc.x = dc.y = 0;
-	dc.w = wstextwidth;
-	drawtext(wstext, dc.norm);
-	dc.x = dc.w;
-	dc.w = blw;
-	drawtext(layout[selws-1]->symbol, dc.norm);
-	x = dc.x + dc.w;
-	dc.w = textw(stext);
-	dc.x = sw - dc.w;
-	if(dc.x < x) {
-		dc.x = x;
-		dc.w = sw - x;
-	}
-	drawtext(stext, dc.norm);
-	if((dc.w = dc.x - x) > bh) {
-		dc.x = x;
-		if(sel) {
-			drawtext(sel->name, dc.sel);
+	for(i = 0; i < screenmax; i++) {
+		dc.x = dc.y = 0;
+		dc.w = wstextwidth;
+		drawtext(wstext, dc.norm);
+		dc.x = dc.w;
+		dc.w = blw;
+		drawtext(layout[selws-1]->symbol, dc.norm);
+		x = dc.x + dc.w;
+		dc.w = textw(stext);
+		dc.x = sw[i] - dc.w;
+		if(dc.x < x) {
+			dc.x = x;
+			dc.w = sw[i] - x;
+		}
+		drawtext(stext, dc.norm);
+		if((dc.w = dc.x - x) > bh) {
+			dc.x = x;
+			if(sel) {
+				drawtext(sel->name, dc.sel);
+			}
+			else
+				drawtext(NULL, dc.norm);
 		}
-		else
-			drawtext(NULL, dc.norm);
+		XCopyArea(dpy, dc.drawable, barwin[i], dc.gc, 0, 0, sw[i], bh, 0, 0);
 	}
-	XCopyArea(dpy, dc.drawable, barwin, dc.gc, 0, 0, sw, bh, 0, 0);
 	XSync(dpy, False);
 }
 
@@ -642,11 +659,14 @@ eprint(const char *errstr, ...) {
 
 void
 expose(XEvent *e) {
+	unsigned int i;
 	XExposeEvent *ev = &e->xexpose;
 
 	if(ev->count == 0) {
-		if(ev->window == barwin)
-			drawbar();
+		for(i = 0; i < screenmax; i++) {
+			if(ev->window == barwin[i])
+				drawbar();
+		}
 	}
 }
 
@@ -965,20 +985,20 @@ manage(Window w, XWindowAttributes *wa) 
 	c->w = wa->width;
 	c->h = wa->height;
 	c->oldborder = wa->border_width;
-	if(c->w == sw && c->h == sh) {
-		c->x = sx;
-		c->y = sy;
+	if(c->w == sw[SCREEN] && c->h == sh[SCREEN]) {
+		c->x = sx[SCREEN];
+		c->y = sy[SCREEN];
 		c->border = wa->border_width;
 	}
 	else {
-		if(c->x + c->w + 2 * c->border > wax + waw)
-			c->x = wax + waw - c->w - 2 * c->border;
-		if(c->y + c->h + 2 * c->border > way + wah)
-			c->y = way + wah - c->h - 2 * c->border;
-		if(c->x < wax)
-			c->x = wax;
-		if(c->y < way)
-			c->y = way;
+		if(c->x + c->w + 2 * c->border > wax[SCREEN] + waw[SCREEN])
+			c->x = wax[SCREEN] + waw[SCREEN] - c->w - 2 * c->border;
+		if(c->y + c->h + 2 * c->border > way[SCREEN] + wah[SCREEN])
+			c->y = way[SCREEN] + wah[SCREEN] - c->h - 2 * c->border;
+		if(c->x < wax[SCREEN])
+			c->x = wax[SCREEN];
+		if(c->y < way[SCREEN])
+			c->y = way[SCREEN];
 		c->border = BORDERPX;
 	}
 	XSetWindowBorder(dpy, w, dc.norm[ColBorder]);
@@ -1029,7 +1049,9 @@ movemouse(Client *c) {
 	unsigned int dui;
 	Window dummy;
 	XEvent ev;
-
+	int bartop = (BARPOS == BarTop) ? bh : 0;
+	int barbot = (BARPOS == BarBot) ? bh : 0;
+	
 	ocx = nx = c->x;
 	ocy = ny = c->y;
 	if(XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
@@ -1047,19 +1069,20 @@ movemouse(Client *c) {
 		case Expose:
 		case MapRequest:
 			handler[ev.type](&ev);
-			break;
+ 			break;
 		case MotionNotify:
 			XSync(dpy, False);
 			nx = ocx + (ev.xmotion.x - x1);
 			ny = ocy + (ev.xmotion.y - y1);
-			if(abs(wax + nx) < SNAP)
-				nx = wax;
-			else if(abs((wax + waw) - (nx + c->w + 2 * c->border)) < SNAP)
-				nx = wax + waw - c->w - 2 * c->border;
-			if(abs(way - ny) < SNAP)
-				ny = way;
-			else if(abs((way + wah) - (ny + c->h + 2 * c->border)) < SNAP)
-				ny = way + wah - c->h - 2 * c->border;
+			// TODO: snap to screen borders instead of global borders?
+			if(abs(totalx + nx) < SNAP)
+				nx = totalx;
+			else if(abs((totalx + totalw) - (nx + c->w + 2 * c->border)) < SNAP)
+				nx = totalx + totalw - c->w - 2 * c->border;
+			if(abs((totaly + bartop) - ny) < SNAP)
+				ny = totaly + bartop;
+			else if(abs((totaly + totalh - barbot) - (ny + c->h + 2 * c->border)) < SNAP)
+				ny = totaly + totalh - barbot - c->h - 2 * c->border;
 			resize(c, nx, ny, c->w, c->h, False);
 			break;
 		}
@@ -1151,14 +1174,14 @@ resize(Client *c, int x, int y, int w, i
 	if(w <= 0 || h <= 0)
 		return;
 	/* offscreen appearance fixes */
-	if(x > sw)
-		x = sw - w - 2 * c->border;
-	if(y > sh)
-		y = sh - h - 2 * c->border;
-	if(x + w + 2 * c->border < sx)
-		x = sx;
-	if(y + h + 2 * c->border < sy)
-		y = sy;
+	if(x > totalw)
+		x = totalw - w - 2 * c->border;
+	if(y > totalh)
+		y = totalh - h - 2 * c->border;
+	if(x + w + 2 * c->border < totalx)
+		x = totalx;
+	if(y + h + 2 * c->border < totaly)
+		y = totaly;
 	if(c->x != x || c->y != y || c->w != w || c->h != h) {
 		setborderbyfloat(c, False);
 		c->x = wc.x = x;
@@ -1224,7 +1247,7 @@ restack(void) {
 		XRaiseWindow(dpy, sel->win);
 	if(layout[selws-1]->arrange != floating) {
 		wc.stack_mode = Below;
-		wc.sibling = barwin;
+		wc.sibling = barwin[SCREEN]; // TODO
 		if(!sel->isfloating) {
 			XConfigureWindow(dpy, sel->win, CWSibling | CWStackMode, &wc);
 			wc.sibling = sel->win;
@@ -1420,11 +1443,6 @@ setup(void) {
 	cursor[CurResize] = XCreateFontCursor(dpy, XC_sizing);
 	cursor[CurMove] = XCreateFontCursor(dpy, XC_fleur);
 
-	/* init geometry */
-	sx = sy = 0;
-	sw = DisplayWidth(dpy, screen);
-	sh = DisplayHeight(dpy, screen);
-
 	/* init modifier map */
 	modmap = XGetModifierMapping(dpy);
 	for(i = 0; i < 8; i++)
@@ -1458,6 +1476,11 @@ setup(void) {
 	initfont(FONT);
 	dc.h = bh = dc.font.height + 2;
 
+	/* init geometry */
+	// init to simple width, expand and update later if xinerama is detected
+	dc.drawable = XCreatePixmap(dpy, root, DisplayWidth(dpy, screen), bh, DefaultDepth(dpy, screen)); 
+	updatexinerama();
+
 	/* init layouts */
 	for(i = 0; i < MAXWORKSPACES; i++) {
 		mwfact[i] = MWFACT;
@@ -1468,20 +1491,10 @@ setup(void) {
 		if(j > blw)
 			blw = j;
 	}
-
 	/* init bar */
 	bpos = BARPOS;
-	wa.override_redirect = 1;
-	wa.background_pixmap = ParentRelative;
-	wa.event_mask = ButtonPressMask | ExposureMask;
-	barwin = XCreateWindow(dpy, root, sx, sy, sw, bh, 0,
-			DefaultDepth(dpy, screen), CopyFromParent, DefaultVisual(dpy, screen),
-			CWOverrideRedirect | CWBackPixmap | CWEventMask, &wa);
-	XDefineCursor(dpy, barwin, cursor[CurNormal]);
-	updatebarpos();
-	XMapRaised(dpy, barwin);
+	createbarwins();
 	strcpy(stext, "dwm-"VERSION);
-	dc.drawable = XCreatePixmap(dpy, root, sw, bh, DefaultDepth(dpy, screen));
 	dc.gc = XCreateGC(dpy, root, 0, 0);
 	XSetLineAttributes(dpy, dc.gc, 1, LineSolid, CapButt, JoinMiter);
 	if(!dc.font.set)
@@ -1503,6 +1516,31 @@ setup(void) {
 }
 
 void
+createbarwins(void) {
+	unsigned int i;
+	XSetWindowAttributes wa;
+
+	wa.cursor = cursor[CurNormal];
+	wa.override_redirect = 1;
+	wa.background_pixmap = ParentRelative;
+	wa.event_mask = ButtonPressMask | ExposureMask;
+
+	printf("createbarwins\nd%d r%d b%d s%d w%d\n", dpy, root, bh, screen, wa);
+	for(i = 0; i < screenmax; i++) {
+		printf("[%d] x%d y%d w%d h%d\n", i, sx[i], sy[i], sw[i], sh[i]);
+		barwin[i] = XCreateWindow(dpy, root, sx[i], sy[i], sw[i], bh, 0,
+			DefaultDepth(dpy, screen), CopyFromParent, DefaultVisual(dpy, screen),
+			CWOverrideRedirect | CWBackPixmap | CWEventMask, &wa);
+		XDefineCursor(dpy, barwin[i], cursor[CurNormal]);
+	}
+	printf("\n");
+	updatebarpos();
+	for(i = 0; i < screenmax; i++)
+		XMapRaised(dpy, barwin[i]);
+	XSync(dpy, False);
+}
+
+void
 sigusr1(int notused) {
 	quit(NULL);
 	reload = True;
@@ -1582,28 +1620,28 @@ tile(void) {
 		n++;
 
 	/* window geoms */
-	mw = (n == 1) ? waw : mwfact[selws-1] * waw;
-	th = (n > 1) ? wah / (n - 1) : 0;
+	mw = (n == 1) ? waw[SCREEN] : mwfact[selws-1] * waw[SCREEN];
+	th = (n > 1) ? wah[SCREEN] / (n - 1) : 0;
 	if(n > 1 && th < bh)
-		th = wah;
+		th = wah[SCREEN];
 
-	nx = wax;
-	ny = way;
+	nx = wax[SCREEN];
+	ny = way[SCREEN];
 	nw = 0; /* gcc stupidity requires this */
 	for(i = 0, c = mc = nexttiled(clients); c; c = nexttiled(c->next), i++) {
 		c->ismax = False;
 		if(i == 0) { /* master */
 			nw = mw - 2 * c->border;
-			nh = wah - 2 * c->border;
+			nh = wah[SCREEN] - 2 * c->border;
 		}
 		else {  /* tile window */
 			if(i == 1) {
 				nx += mc->w + 2 * mc->border;
-				ny = way;
-				nw = waw - nx - 2 * c->border;
+				ny = way[SCREEN];
+				nw = waw[SCREEN] - nx - 2 * c->border;
 			}
 			if(i + 1 == n) /* remainder */
-				nh = (way + wah) - ny - 2 * c->border;
+				nh = (way[SCREEN] + wah[SCREEN]) - ny - 2 * c->border;
 			else
 				nh = th - 2 * c->border;
 		}
@@ -1611,7 +1649,7 @@ tile(void) {
 		if((RESIZEHINTS) && ((c->h < bh) || (c->h > nh) || (c->w < bh) || (c->w > nw)))
 			/* client doesn't accept size constraints */
 			resize(c, nx, ny, nw, nh, False);
-		if(n > 1 && th != wah)
+		if(n > 1 && th != wah[SCREEN])
 			ny = c->y + c->h + 2 * c->border;
 	}
 }
@@ -1626,29 +1664,29 @@ tileleft(void) {
 		n++;
 
 	/* window geoms */
-	mw = (n == 1) ? waw : mwfact[selws-1] * waw;
-	th = (n > 1) ? wah / (n - 1) : 0;
+	mw = (n == 1) ? waw[SCREEN] : mwfact[selws-1] * waw[SCREEN];
+	th = (n > 1) ? wah[SCREEN] / (n - 1) : 0;
 	if(n > 1 && th < bh)
-		th = wah;
+		th = wah[SCREEN];
 
-	nx = wax;
-	ny = way;
+	nx = wax[SCREEN];
+	ny = way[SCREEN];
 	nw = 0; /* gcc stupidity requires this */
 	for(i = 0, c = mc = nexttiled(clients); c; c = nexttiled(c->next), i++) {
 		c->ismax = False;
 		if(i == 0) { /* master */
-			nx = waw - mw + 2 * c->border;
+			nx = waw[SCREEN] - mw + 2 * c->border;
 			nw = mw - 2 * c->border;
-			nh = wah - 2 * c->border;
+			nh = wah[SCREEN] - 2 * c->border;
 		}
 		else {  /* tile window */
 			if(i == 1) {
-				nx = wax;
-				ny = way;
-				nw = waw - mw - 2 * mc->border;
+				nx = wax[SCREEN];
+				ny = way[SCREEN];
+				nw = waw[SCREEN] - mw - 2 * mc->border;
 			}
 			if(i + 1 == n) /* remainder */
-				nh = (way + wah) - ny - 2 * c->border;
+				nh = (way[SCREEN] + wah[SCREEN]) - ny - 2 * c->border;
 			else
 				nh = th - 2 * c->border;
 		}
@@ -1656,7 +1694,7 @@ tileleft(void) {
 		if((RESIZEHINTS) && ((c->h < bh) || (c->h > nh) || (c->w < bh) || (c->w > nw)))
 			/* client doesn't accept size constraints */
 			resize(c, nx, ny, nw, nh, False);
-		if(n > 1 && th != wah)
+		if(n > 1 && th != wah[SCREEN])
 			ny = c->y + c->h + 2 * c->border;
 	}
 }
@@ -1695,7 +1733,7 @@ togglemax(const char *arg) {
 		sel->ry = sel->y;
 		sel->rw = sel->w;
 		sel->rh = sel->h;
-		resize(sel, wax + sel->border, way + sel->border, waw - 2 * sel->border, wah - 2 * sel->border, True);
+		resize(sel, wax[SCREEN] + sel->border, way[SCREEN] + sel->border, waw[SCREEN] - 2 * sel->border, wah[SCREEN] - 2 * sel->border, True);
 	}
 	else {
 		resize(sel, sel->rx, sel->ry, sel->rw, sel->rh, True);
@@ -1829,24 +1867,27 @@ unmapnotify(XEvent *e) {
 void
 updatebarpos(void) {
 	XEvent ev;
+	int i;
 
-	wax = sx;
-	way = sy;
-	wah = sh;
-	waw = sw;
-	switch(bpos) {
-	default:
-		wah -= bh;
-		way += bh;
-		XMoveWindow(dpy, barwin, sx, sy);
-		break;
-	case BarBot:
-		wah -= bh;
-		XMoveWindow(dpy, barwin, sx, sy + wah);
-		break;
-	case BarOff:
-		XMoveWindow(dpy, barwin, sx, sy - bh);
-		break;
+	for(i = 0; i < screenmax; i++) {
+		wax[i] = sx[i];
+		way[i] = sy[i];
+		wah[i] = sh[i];
+		waw[i] = sw[i];
+		switch(bpos) {
+		default:
+			wah[i] -= bh;
+			way[i] += bh;
+			XMoveWindow(dpy, barwin[i], sx[i], sy[i]);
+			break;
+		case BarBot:
+			wah[i] -= bh;
+			XMoveWindow(dpy, barwin[i], sx[i], sy[i] + wah[i]);
+			break;
+		case BarOff:
+			XMoveWindow(dpy, barwin[i], sx[i], sy[i] - bh);
+			break;
+		}
 	}
 	XSync(dpy, False);
 	while(XCheckMaskEvent(dpy, EnterWindowMask, &ev));
@@ -1970,6 +2011,56 @@ zoom(const char *arg) {
 	arrange();
 }
 
+void
+updatexinerama(void) {
+	XineramaScreenInfo *xinescreens;
+	int xinescreencount;
+	unsigned int i;
+
+
+	if( ! XineramaIsActive(dpy) ) {
+		/* no Xinerama available, fallback */
+		sx[0] = sy[0] = 0;
+		sw[0] = totalw = DisplayWidth(dpy, screen);
+		sh[0] = totalh = DisplayHeight(dpy, screen);
+		screenmax = 1;
+		return;
+	}
+	
+	destroybarwins();
+	XFreePixmap(dpy, dc.drawable);
+        xinescreens = XineramaQueryScreens(dpy, &xinescreencount);
+	screenmax = 0;
+	totalw = totalh = 0;
+	printf("updatexinerama\n");
+	for(i = 0; i < xinescreencount; i++) {
+		printf("screen %d = x%d y%d w%d h%d ", xinescreens[i].screen_number, xinescreens[i].x_org, xinescreens[i].y_org, xinescreens[i].width, xinescreens[i].height);
+		/* if adjacent screens overlap in their starting position, take the bigger one (clone output detection) */
+		if(i == 0 || sx[screenmax-1] != xinescreens[i].x_org || sy[screenmax-1] != xinescreens[i].y_org) {
+			printf("--> take as new\n");
+			sx[screenmax] = xinescreens[i].x_org;
+			sy[screenmax] = xinescreens[i].y_org;
+			sw[screenmax] = xinescreens[i].width;
+			sh[screenmax] = xinescreens[i].height;
+			screenmax++;
+		} else {
+			printf("--> morph together\n");
+			if (sw[screenmax-1] < xinescreens[i].width)
+				sw[screenmax-1] = xinescreens[i].width;
+			if (sh[screenmax-1] < xinescreens[i].height)
+				sh[screenmax-1] = xinescreens[i].height;
+		}
+		if (sx[screenmax-1] + sw[screenmax-1] > totalw)
+			totalw = sx[screenmax-1] + sw[screenmax-1];
+		if (sy[screenmax-1] + sh[screenmax-1] > totalh)
+			totalh = sy[screenmax-1] + sh[screenmax-1];
+	}
+	printf("screenmax=%d\n\n", screenmax);
+	XFree(xinescreens);
+	dc.drawable = XCreatePixmap(dpy, root, totalw, bh, DefaultDepth(dpy, screen)); 
+	createbarwins();
+}
+
 int
 main(int argc, char *argv[]) {
 	if(argc == 2 && !strcmp("-v", argv[1]))
diff -Narup 10_dwm-4.7_tileleft/maximize.c 11_dwm-4.7_xinerama/maximize.c
--- 10_dwm-4.7_tileleft/maximize.c	2010-02-19 22:12:14.000000000 +0100
+++ 11_dwm-4.7_xinerama/maximize.c	2010-02-19 22:12:14.000000000 +0100
@@ -6,7 +6,7 @@ maximize(void) {
                 if (isvisible(c)) {
                         unban(c);
                         if(! c->isfloating)
-                                resize(c, wax, way, waw - 2 * BORDERPX, wah - 2 * BORDERPX, True);
+                                resize(c, wax[SCREEN], way[SCREEN], waw[SCREEN] - 2 * BORDERPX, wah[SCREEN] - 2 * BORDERPX, True);
                 } else {
                         ban(c);
                 }
